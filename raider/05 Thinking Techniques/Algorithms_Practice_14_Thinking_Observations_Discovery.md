# Thinking - Observations Discovery

In many cases, a hard problem is based on observations.  
Actually, one observation may lead to a solution, while another lead to a different one.

## Discovery through Test Cases

One of the best ways to discover properties of a problem is through test case **TRACING**.  
Pick test cases one by one, from smaller to larger. Trace the sample & try to discover properties & patterns.  
As long as tracing new bigger samples helps you think/understand more, trace more.

Typically, properties are **ad-hoc**, and this is what makes them hard.  
E.g., the problem depends on a given triangle with certain construction steps, say similar to Pascal's triangle. Finding its properties is the key.

The worst scenario is when you dig for properties that are **not** the key for the solution.

## Code vs Paper

Sometimes, it is hard to discover the properties by analysis on papers. Try to write some **SAMPLE** code on a PC.  
E.g., brute force solution and see the output - enumerating sequence elements to find patterns.

**NEVER** start by the PC to find observations. Always try on papers first, and move to code if stuck.  
Remember, code = bugs. So avoid big codes for observations, to avoid losing your time.  
It's your turn to balance between the need to work on paper vs PC.

## Some Popular Properties

### Sparseness

E.g., You have State `(X, Y)` and move to State `(X/2, Y/3)`. X, Y is 10^9, but we have only `log(X) * log(Y)` states.

### Constrained Input Combinations

When not every input combination is valid.  
E.g., Say input `X <= N` and `Y <= M`, typically we expect `N*M` possible inputs.  
But given is that X's binary representation won't intersect with Y's binary representation.

### Symmetry

The output 2D array is symmetric - `F(angle)` is symmetric in `[0-π]`.  
The given sequence repeats in a symmetric way.

### Inference

E.g., `Z = 2*(X+Y) + 3`, `Height = Area(mask) / Width`  
Then we don't need to think in the inferred variables.

### Redundancy

- Button if clicked is on, if re-clicked is off. It doesn’t matter how many times clicked. Either even or odd clicks.
- Clock moves, after some moves, it back to original.

### Independency

A problem could be simplified by realizing its parts.

- Minimize some Manhattan Distance = Minimize on Xs + Minimize on Ys
- `F(Start, End) = F(Start, MID) + F(MID, End)` For every possible Mid
- In probability: When Trials are Independent, then: sum of the expectations = expectation of the sum
- Independent Games (Grundy)

### Ad-hoc

Given a set of words, align them. Given rule to align 2 consecutive words. Then, each word is dependent **only** on the previous word.

### IO Re-representation

E.g.,  
- Given input graph, is it: `Tree, DAG, Complete, Bipartite`
- Given Array → `Sorted array, Frequency Array`

### Classification of Input

- Given input graph, is it: Tree, DAG, Complete, Bipartite?
- Given polygon, is it: Convex? Concave? General?

### Modulo Calculations

Given `X`, find the smallest `Y` such that `X % Y ...`?  
Then we care only with **MODE**.

### Find Numbers with Property X

E.g., palindromes  
- a) You could try all Xs and check if `IsPalindrome(X)`
- b) Find properties of `X` to directly generate it.

### Find Count of Numbers with Properties p1 & p2 (e.g., prime & palindromes)

How many `p1`s? `p2`s? Who to generate first?

### Find Tuples with Property: At Least One of Them >= D

Negation of `= Find tuples with each one < D-1`.

### Find Tuples with Property: Each One of Them <= D1 AND At Least One of Them >= D2

`= Range Subtraction of {Each one of them <= D1} - {Each one of them <= D2-1}`  
**Note:** Y’s property = Don’t Include `!Y`. Double Negation.

### Algorithmic Input Construction

Is input built in an algorithmic way? It may be the clue.  
- Large 2D array, but it is just `(N/5, N/5)` repeated everywhere.
- Graph constructed by repeating a certain operation.
- Sequence generated by a certain formula: `A[i] = oper(A[i-1]) % D`

### Splitting vs Combining

1. One big object (e.g., polygon) consists of `N` small objects (e.g., triangle). Can the `N` elements fit in the big object?  
   - Try splitting big objects into small ones.  
   - Try to merge small objects into a big one.

### At Most vs Exact

- `atmost(n) = exact(1) + exact(2) ... exact(n)`
- `exact(n) = atmost(n) - atmost(n-1)`

### Canonical Form

When you need to compare two things, think about **CANONICAL form** for one-to-one correspondence.

### Fast Reduction

E.g., we have `F(X)`, but it moves to `F(X/2)`. Even `X` with `10^18`, it finishes in `log(X)` steps.

### Cycle Tricks

Say we evaluate `a^0 % n`, `a^1 % n`, `a^2 % n` ... `a^k % n`. Let `k > n`.  
Then at some `a^t = a^f` where `f < t`. In other words, this mod value appeared before. So the sequence of mods repeats.

### Input Function Nature

- **Exponential**  
- `F(X > Limit) = Constant`
- **Increasing Sequence**
- **Unimodal Sequence:** A function that is either increasing and then decreasing, or vice versa.
