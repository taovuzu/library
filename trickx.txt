// Arrays, Vectors, Sequences
a, b, c, d, e, arr, vec

// Loop Indices
i, j, h, i_, j_, k_, id, idx, cur

// Counters / Temporary / Result
cnt, temp, res, ans, sum, total, score, best, worst, minv, maxv, ret

// Frequency / Flags / State
f, vis, used, mark, alive, dead, ok, fail, done, flag, on, off

// Graphs & Trees
g, adj, edges, tree, u, v, node, par, ch, deg, tin, tout, low

// Geometry / Range / Coordinates
x, y, z, x_, y_, l, r, m, mid, left, right, dx, dy, pt, seg, rect

// Strings
s, s1, s2, s3

// Maps
mp, mp1, mp2

// Sets
xt, xt1, xt2, seen, uniq

// Stacks, Queues, Priority Queues
sk, sk1, sk2, qu, qu1, qu2, pq, pq1, pq2

// Pairs, Tuples
p, p1, p2, p3, p4, tp, tp1, tp2, tp3

// Dynamic Programming
dp, dp1, dp2, memo, cache, pre, suf

// Segment Trees / BIT / RMQ
sx, sx1, sx2

// Binary Search
lo, hi, mid, ub, lb

// Queries
q, q1, q2

// Iterators
it


// max allowed size for 256 mb -> 2 * 1e7 n;

// __builtin's works on unsigned numbers only
// __builtin_popcountll(x)     -> returns the number of 1's
// __builtin_clzll(x)          -> returns the count of leading zero's, Undefined behavior on zero
// __builtin_ctzll(x)          -> returns the count of trailing zero's, Undefined behavior on zero

The Golden Rule: Always put the variable you're checking on the left side of the comparison. For the range check put them as like the we denote ranges in maths


// Note: Div2 Strategy

// Problem A (Estimated ~800-1000): 0 - 10 minutes. Do not prove it, just trust your gut and code.
// Problem B (Estimated ~1100-1400): 10 - 25 minutes. Usually greedy or simple math. Keep code short.
// Problem C (Estimated ~1400-1700): 25 - 55 minutes. This is where AI causes the most inflation. Be meticulously careful with your implementation and edge cases (N=1, zeros, negative numbers). A penalty here destroys your delta.
// Problem D (Estimated ~1700-1900+): 55 - 110 minutes. This is your CM battleground. You have a full hour. This is pure problem-solving time.

// Read Problem E. Sometimes E is a standard data structure problem (easier to implement) while D or C is a weird brain-teaser. Come back to D or C after resetting your brain.

// How to use it: After reading the problem, give yourself exactly 10 minutes on paper. If you cannot reduce the problem to a known paradigm (e.g., "This is just binary search on the answer," or "I just need to find the shortest path in a modified graph") or find a solid greedy invariant within those 10 minutes, you are missing a critical mathematical observation. Action: Step away. Read Next Problem.